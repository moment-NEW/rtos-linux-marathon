
- 周次：W1
- 时间范围：2026-1-13 ~ 2026-1-20
- 本周重点（3+1 模式中的本周定位）：代码文档+最小实验
QEMU,交叉编译,git,工具链
- 本周完成：
  - 代码/补丁/PR：

  - 实验/数据：

  - 阅读/学习：【[Linux] 命令行工具集合 Busybox 编译实战】 https://www.bilibili.com/video/BV1yt4y1j765/?share_source=copy_web&vd_source=8b034ca64cb8bbbd15b0969aebfe1501

- 遇到的问题 & 解决进展：
D1:  
今天抽空去Linux官网找了下源码。kernel.org，域名很简单（虽然中间误入了个什么kernal.org的奇怪网站），但是下载很慢，后面去找了linus托管在github的镜像，也拉的很慢，用于学习的虚拟机上也没装梯子，所以本机拉了一份tar.gz下来，scp到了学习机上。安装了QEMU，不过不知道在虚拟机上再搞虚拟，跑起来会怎么样。  
D2：  
由于已经有一点RTOS使用经验，遂搜了一点相关资料，开始直接编译Linux内核。值得一提的是linux的编译很神奇，有一套用于config的工具，还有一些默认参数比如Kconfig等等，需要先make menuconfig等配置工具，生成.config才能进行编译。编译直接使用指令make -j 20，表示用20线程进行编译，耗时较长，后面考虑给这个虚拟机更多线程。期间一直遇到Erro2，以及环境不充分的问题。不过最后还是成功build了一个bzimage文件。
D3:
明天要进行离散考试，遂没做什么实际工作，翻阅了一下RT-Thread的贡献文档等等。买了一块喵板，打算给其贡献一个喵板的部署示例作为练习。
- 下周计划：
- 需要协助/决策：
- 备注（链接/日志/截图）：
这是和Copliot探讨的时候学到的知识：
>要看懂 Linux 内核的编译日志，其实只要掌握其 **“动作前缀”** 和 **“构建顺序”** 就行了。内核为了简洁，默认使用了缩写输出。

>以下是看懂日志的快捷手册：

>### 1. 常见的前缀含义
>内核编译时，每一行开头都有一个大写的缩写，代表正在执行的动作：

>*   **`CC`** : (C Compiler) 正在编译 `.c` 源文件生成 `.o` 目标文件。这是最常见的输出。
>*   **`AS`** : (Assembler) 正在编译 `.S` 汇编文件。
>*   **`LD`** : (Linker) 正在把一堆 `.o` 文件链接在一起。
>*   **`AR`** : (Archiver) 正在创建静态库 `.a` 文件。
>*   **`HOSTCC` / `HOSTLD`** : 正在编译运行在**当前主机**上的一些小工具（比如 `menuconfig` 界面工具），而不是编译内核本身的代码。
>*   **`GEN`** : (Generate) 正在通过脚本生成某些文件（比如你刚才报错的 `modules.builtin.ranges`）。
>*   **`[M]`** : 如果前缀后面带一个 `[M]`（例如 `CC [M]`），说明这个文件是作为 **“模块”**（外挂驱动）编译的，而不是直接编译进内核镜像内部。

>### 2. 编译的“三部曲”
日志的执行顺序是有逻辑的，通常分为以下三个阶段：

>#### 第一阶段：准备工作 (Prepare)
这一阶段你会看到大量的 `HOSTCC`。
*   它在编译 `scripts/` 目录下的工具。
*   在检查系统调用表 (`checksyscalls.sh`)。
*   为你的 CPU 架构生成头文件。

>#### 第二阶段：编译对象 (Object Building)
这是最耗时的一段，你会看到几千行 `CC` 输出。
*   内核会按照目录结构递归编译：`arch/x86/` -> `kernel/` -> `mm/` -> `fs/` -> `drivers/`。
*   如果你看到 `AR  drivers/built-in.a`，说明整个驱动目录下的代码已经打包完成了。

>#### 第三阶段：链接与打包 (Linking & Finalizing)
当你看到日志接近尾声时，会出现以下几个关键文件：
1.  **`vmlinux`**：这是内核的“真身”，一个巨大的、未压缩的 ELF 可执行文件。
2.  **`modules.order` / `modules.builtin`**：正在整理哪些是外挂模块，哪些是内置驱动。
3.  **`bzImage`**：这是你最终在 boot 目录下看到的那个压缩过的内核镜像。看到 **"Kernel: arch/x86/boot/bzImage is ready"**，就说明大功告成了。

>### 3. 如何看懂错误日志？
错误通常不难找，重点看 **“Error”** 以上的 5-10 行：
*   **Error 127**：一般是“命令找不到”（比如你遇到的 `gawk: not found`）。
*   **Error 1** / **Error 2**：通常是代码语法错误或链接时找不到符号。
*   **No rule to make target '...'**：通常是 `.config` 里指向了一个不存在的文件（比如你遇到的证书文件路径问题）。

>### 进阶技巧：看详细命令
如果你觉得 `CC  xxx.o` 太简洁了，想看具体用了什么 gcc 参数，可以在执行时加上 `V=1`：
```bash
make -j 20 V=1
```
这时候你会看到每一行都变成了冗长的 `gcc -Wp,-MMD...`。这在调试复杂的头文件包含错误时非常有用。
